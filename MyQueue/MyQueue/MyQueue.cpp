#include "MyQueue.h"
#include <stdexcept> // Для std::out_of_range
#include <iostream>  // Для отладки (необязательно)

Queue::Queue(size_t capacity) : head(0), tail(0), size(0), capacity(capacity) {
    // Выделяем память для data динамически
    data = new void* [capacity];

    if (data == nullptr) {
        std::cerr << "Ошибка выделения памяти для очереди!" << std::endl;
        // Можно выбросить исключение или предпринять другие меры по обработке ошибок
    }
}

Queue::~Queue() {
    // Деструктор класса Queue.
    // Освобождает ресурсы, выделенные классом.

    // Важно: Так как очередь хранит указатели, а не сами объекты,
    // освобождать память, на которую указывают элементы очереди,
    // должен вызывающий код (например, в main()).
    // В противном случае, произойдет утечка памяти.

    // Освобождаем память, выделенную для массива data
    delete[] data;

    //Можно раскомментировать следующий код, чтобы очистить указатели внутри data,
    //однако нужно помнить, что освобождать саму память, на которую они указывают, нельзя.
    //for (size_t i = 0; i < size; ++i) {
    //  data[i] = nullptr;
    //}
}

bool Queue::enqueue(void* item) {
    // Метод для добавления элемента в очередь.
    //  Параметры:
    //   - item: указатель void* на добавляемый элемент (универсальный указатель).
    //  Возвращает:
    //   - true: элемент успешно добавлен.
    //   - false: очередь заполнена, элемент не добавлен.
    if (isFull()) {
        return false; // Очередь заполнена, не можем добавить элемент
    }
    data[tail] = item; // Добавляем указатель на элемент в массив data в позицию tail.
    tail = (tail + 1) % capacity; // Перемещаем tail на следующую позицию, используя оператор %.
    //  Оператор % обеспечивает цикличность: если tail достигает конца массива,
    //  он переходит в начало. Используем capacity, чтобы циклически перемещаться по массиву.
    size++;                          // Увеличиваем размер очереди.
    return true;                     // Элемент успешно добавлен.
}

void* Queue::dequeue() {
    // Метод для удаления элемента из очереди.
    //  Возвращает:
    //   - указатель void* на удаленный элемент.
    //   - nullptr: очередь пуста, нечего удалять.
    if (isEmpty()) {
        return nullptr; // Очередь пуста, нечего удалять.
    }
    void* item = data[head];          // Получаем указатель на элемент, который нужно удалить (из начала очереди).
    data[head] = nullptr;             // Очищаем ячейку (не обязательно, но хорошая практика, чтобы избежать висячих указателей).
    head = (head + 1) % capacity; // Перемещаем head на следующую позицию, используя оператор %.
    //  Оператор % обеспечивает цикличность. Используем capacity.
    size--;                          // Уменьшаем размер очереди.
    return item;                     // Возвращаем указатель на удаленный элемент.
}

void* Queue::peekFront() const {
    // Метод для получения указателя на первый элемент в очереди (без удаления).
    //  Возвращает:
    //   - указатель void* на первый элемент.
    //   - nullptr: очередь пуста.
    if (isEmpty()) {
        return nullptr; // Очередь пуста
    }
    return data[head]; // Возвращаем указатель на первый элемент.
}

void* Queue::peekBack() const {
    // Метод для получения указателя на последний элемент в очереди (без удаления).
    //  Возвращает:
    //   - указатель void* на последний элемент.
    //   - nullptr: очередь пуста.
    if (isEmpty()) {
        return nullptr; // Очередь пуста
    }

    // Индекс последнего элемента. Если tail указывает на свободную ячейку, то последний элемент находится перед tail.
    size_t backIndex = (tail == 0) ? (capacity - 1) : (tail - 1); // Учитываем цикличность, используя capacity.

    return data[backIndex]; // Возвращаем указатель на последний элемент.
}

bool Queue::isEmpty() const {
    // Метод для проверки, пуста ли очередь.
    return size == 0; // Очередь пуста, если size равен 0.
}

bool Queue::isFull() const {
    // Метод для проверки, заполнена ли очередь.
    return size == capacity; // Очередь заполнена, если size равен capacity.
}

size_t Queue::getSize() const {
    // Метод для получения текущего размера очереди.
    return size; // Возвращаем текущее количество элементов в очереди.
}

size_t Queue::getCapacity() const {
    // Метод для получения вместимости очереди.
    return capacity; // Возвращаем вместимость очереди.
}
