#include <iostream>
#include "MyQueue.h"   // Подключаем заголовочный файл вашей библиотеки Queue

using namespace std;

// Функция для печати первых n натуральных чисел,
// в разложение которых на простые множители входят только 2, 3 и 5.
void printUglyNumbers(int n) {
    // Параметры:
    //   - n: Количество "некрасивых" чисел (ugly numbers), которые необходимо вывести.
    if (n <= 0) {
        cout << "Необходимо положительное количество чисел." << endl; // Выводим сообщение об ошибке, если n не положительное.
        return;                                                        // Завершаем выполнение функции, если n не положительное.
    }

    // Создаем три очереди для чисел, умноженных на 2, 3 и 5.
    Queue queue2(n * 2); // Создаем очередь для чисел, кратных 2, с вместимостью n * 2.
    Queue queue3(n * 3); // Создаем очередь для чисел, кратных 3, с вместимостью n * 3.
    Queue queue5(n * 5); // Создаем очередь для чисел, кратных 5, с вместимостью n * 5.
    //  Размер каждой очереди определяется как n * множитель (2, 3 или 5).
    //  Это эвристическая оценка, которая может быть скорректирована в зависимости от
    //  необходимого количества чисел и производительности.

    // Первое "некрасивое" число - 1.
    cout << "1 ";

    // Инициализируем очереди начальными значениями (2, 3, 5).
    int* num2 = new int(2); // Выделяем память для числа 2 на куче.
    int* num3 = new int(3); // Выделяем память для числа 3 на куче.
    int* num5 = new int(5); // Выделяем память для числа 5 на куче.
    //  Важно: Память выделяется динамически, так как очередь хранит указатели.

    queue2.enqueue(num2);   // Помещаем в очередь queue2 (кратные 2) указатель на число 2.
    queue3.enqueue(num3);   // Помещаем в очередь queue3 (кратные 3) указатель на число 3.
    queue5.enqueue(num5);   // Помещаем в очередь queue5 (кратные 5) указатель на число 5.

    int next;               // Переменная для хранения следующего "некрасивого" числа.

    // Генерируем остальные n-1 чисел Хэмминга (ugly numbers).
    for (int i = 1; i < n; ++i) {
        // Находим минимальное значение из начал всех трех очередей.
        // Это минимальное значение является следующим "некрасивым" числом.

        int* nextPtr2 = static_cast<int*>(queue2.peekFront()); // Получаем указатель на первый элемент из queue2 (без удаления).
        int* nextPtr3 = static_cast<int*>(queue3.peekFront()); // Получаем указатель на первый элемент из queue3 (без удаления).
        int* nextPtr5 = static_cast<int*>(queue5.peekFront()); // Получаем указатель на первый элемент из queue5 (без удаления).
        //  Важно: Используем peekFront(), чтобы не удалять элементы из очереди на данном этапе.

        next = *nextPtr2;          // Предполагаем, что первым идет элемент из queue2.

        if (!queue3.isEmpty() && *nextPtr3 < next) { // Если queue3 не пуста и её первый элемент меньше, чем текущий next.
            next = *nextPtr3;      //  Значит, элемент из queue3 является минимальным.
        }
        if (!queue5.isEmpty() && *nextPtr5 < next) {  // Если queue5 не пуста и её первый элемент меньше, чем текущий next.
            next = *nextPtr5;      //  Значит, элемент из queue5 является минимальным.
        }
        //  После этой последовательности if-ов переменная next содержит минимальное число из начал всех трех очередей.

        cout << next << " ";           // Выводим следующее "некрасивое" число.

        // Определяем, из какой очереди было взято минимальное число,
        // и добавляем в соответствующие очереди новые числа, умноженные на 2, 3 и 5.
        if (next == *nextPtr2) { // Если минимальное число было взято из queue2.
            delete static_cast<int*>(queue2.dequeue());  // Освобождаем память, удаляем число из queue2 (из начала очереди).
            //  Важно: Необходимо освободить память, выделенную для элемента, так как
            //  очередь хранит только указатели на элементы.

            int* newNum2 = new int(next * 2);   // Создаем новый элемент, умноженный на 2.
            int* newNum3 = new int(next * 3);   // Создаем новый элемент, умноженный на 3.
            int* newNum5 = new int(next * 5);   // Создаем новый элемент, умноженный на 5.

            queue2.enqueue(newNum2);           // Добавляем новый элемент в queue2.
            queue3.enqueue(newNum3);           // Добавляем новый элемент в queue3.
            queue5.enqueue(newNum5);           // Добавляем новый элемент в queue5.

        } else if (next == *nextPtr3) { // Если минимальное число было взято из queue3.
            delete static_cast<int*>(queue3.dequeue()); // Освобождаем память, удаляем число из queue3.

            int* newNum3 = new int(next * 3);   // Создаем новый элемент, умноженный на 3.
            int* newNum5 = new int(next * 5);   // Создаем новый элемент, умноженный на 5.

            queue3.enqueue(newNum3);           // Добавляем новый элемент в queue3.
            queue5.enqueue(newNum5);           // Добавляем новый элемент в queue5.

        } else {                           // Если минимальное число было взято из queue5.
            delete static_cast<int*>(queue5.dequeue()); // Освобождаем память, удаляем число из queue5.

            int* newNum5 = new int(next * 5);   // Создаем новый элемент, умноженный на 5.

            queue5.enqueue(newNum5);           // Добавляем новый элемент в queue5.
        }
        // Теперь в очередях находятся числа, необходимые для генерации следующих "некрасивых" чисел.
    }

    cout << endl;

    // Очищаем очереди, чтобы избежать утечек памяти.
    while (!queue2.isEmpty()) {        // Пока queue2 не пуста.
        delete static_cast<int*>(queue2.dequeue()); // Удаляем элемент из queue2 и освобождаем память.
    }
    while (!queue3.isEmpty()) {        // Пока queue3 не пуста.
        delete static_cast<int*>(queue3.dequeue()); // Удаляем элемент из queue3 и освобождаем память.
    }
    while (!queue5.isEmpty()) {        // Пока queue5 не пуста.
        delete static_cast<int*>(queue5.dequeue()); // Удаляем элемент из queue5 и освобождаем память.
    }
    // Важно: Освобождение памяти необходимо для предотвращения утечек памяти.
}

int main() {
    // Основная функция программы.
    int n;                         // Переменная для хранения количества чисел, которые необходимо вывести.

    cout << "Введите количество чисел для вывода: "; // Запрашиваем у пользователя ввод количества чисел.
    cin >> n;                     // Считываем введенное пользователем значение в переменную n.

    printUglyNumbers(n);         // Вызываем функцию для генерации и вывода "некрасивых" чисел.

    return 0;                     // Завершаем выполнение программы.
}
